// Generated by CoffeeScript 1.4.0
(function() {
  var child, equal, expect, reakt, spy, watch, _ref;

  _ref = require('assert'), expect = _ref.ok, equal = _ref.equal;

  child = require('child_process');

  watch = require('watch');

  spy = require('bondjs');

  reakt = require('./');

  describe('reakt', function() {
    before(function() {
      return this.createSubject = function(args) {
        if (args == null) {
          args = {};
        }
        this.subject = reakt("/foo/bar", 'ls ..', args);
        return spy(this.subject, 'log')["return"]();
      };
    });
    beforeEach(function() {
      return this.createSubject();
    });
    describe('#start', function() {
      beforeEach(function() {
        spy(watch, 'watchTree')["return"]();
        return spy(this.subject, 'processRestarter')["return"]();
      });
      it('sets an empty process attribute', function() {
        return equal(this.subject.process, null);
      });
      context('when in long running mode', function() {
        return it('wraps the #startProcess method with a #processRestarter', function() {
          var actualStartFn, expectedStartFn;
          this.createSubject({
            longRunning: true
          });
          spy(this.subject, 'processRestarter')["return"]();
          expectedStartFn = this.subject.startProcess;
          this.subject.start();
          actualStartFn = this.subject.processRestarter.calledArgs[0][0];
          return equal(actualStartFn, expectedStartFn);
        });
      });
      context('when not in long running mode', function() {
        return it('does not wrap the startProcess method', function() {
          this.subject.start();
          return expect(!this.subject.processRestarter.called);
        });
      });
      return it('sets a watcher on the provided path', function() {
        var cb, path, _ref1;
        this.subject.start();
        _ref1 = watch.watchTree.calledArgs[0], path = _ref1[0], cb = _ref1[1];
        equal(path, "/foo/bar");
        return equal(cb, this.subject.onChange);
      });
    });
    describe('#onChange', function() {
      beforeEach(function() {
        this.fakeData = ['foo'];
        spy(this.subject, 'parseFiles')["return"](this.fakeData);
        return spy(this.subject, 'startProcess')["return"]();
      });
      context('with no files', function() {
        return it('returns early', function() {
          this.subject.parseFiles["return"]([]);
          this.subject.onChange(this.fakeData);
          return expect(!this.subject.startProcess.called);
        });
      });
      return context('with files', function() {
        return it('calls #runProcess', function() {
          this.subject.parseFiles["return"](['/foo']);
          this.subject.onChange(this.fakeData);
          return expect(this.subject.startProcess.called);
        });
      });
    });
    describe('#parseFiles', function() {
      context('when called with an object', function() {
        return it('converts the objects keys to a string and returns it', function() {
          var result;
          result = this.subject.parseFiles({
            'foo': 'foo',
            'bar': 'bar'
          });
          equal(result[0], 'foo');
          return equal(result[1], 'bar');
        });
      });
      return context('when called with a string', function() {
        return it('returns the original string', function() {
          var result;
          result = this.subject.parseFiles('foo');
          return equal(result[0], 'foo');
        });
      });
    });
    describe('#parseFile', function() {
      beforeEach(function() {
        return this.createSubject({
          include: "(baz\/qux|lorem\/ipsum)",
          exclude: "ipsum\/lorem"
        });
      });
      it('strips the base path', function() {
        return equal(this.subject.parseFile('/foo/bar/baz/qux'), '/baz/qux');
      });
      context('if the file does not match the include pattern', function() {
        return it('returns null', function() {
          return equal(this.subject.parseFile('/foo/bar/foo/ipsum'), null);
        });
      });
      return context('if the file matches the exclude pattern', function() {
        return it('returns null', function() {
          return equal(this.subject.parseFile('/foo/bar/ipsum/lorem'), null);
        });
      });
    });
    describe('#processRestarter', function() {
      beforeEach(function() {
        this.createSubject({
          longRunning: true
        });
        this.subject.process = {};
        spy(this.subject, 'killProcess')["return"]();
        this.onSpy = spy();
        this.startFnSpy = spy()["return"]({
          on: this.onSpy
        });
        this.handler = this.subject.processRestarter(this.startFnSpy);
        return this.handler();
      });
      it('kills the child if one exists', function() {
        return expect(this.subject.killProcess.called);
      });
      it('calls startFn method', function() {
        return expect(this.startFnSpy.called);
      });
      return it('adds a listener to the newly created child', function() {
        var cb, event, _ref1;
        _ref1 = this.onSpy.calledArgs[0], event = _ref1[0], cb = _ref1[1];
        equal(event, 'exit');
        return equal(cb, this.subject.onProcessExit);
      });
    });
    describe('#killProcess', function() {
      return it('kills the process', function() {
        this.subject.process = {
          kill: spy()
        };
        this.subject.killProcess();
        return expect(this.subject.process.kill.called);
      });
    });
    describe('#onProcessExit', function() {
      return it('nullifies the process ref', function() {
        this.subject.process = true;
        this.subject.onProcessExit();
        return expect(!(this.subject.process != null));
      });
    });
    describe('#startProcess', function() {
      return it('spawns a child process', function() {
        var args, cmd, onSpy, opts, _ref1;
        onSpy = spy();
        spy(child, 'spawn')["return"]({
          on: onSpy
        });
        this.subject.startProcess();
        _ref1 = child.spawn.calledArgs[0], cmd = _ref1[0], args = _ref1[1], opts = _ref1[2];
        equal(cmd, 'sh');
        equal(args[0], '-c');
        equal(args[1], 'ls ..');
        return equal(opts.stdio, 'inherit');
      });
    });
    return describe('#onChildExit', function() {});
  });

}).call(this);
